"""
Market Context Subsystem

Tracks broad market conditions including:
1. NIFTY/BANKNIFTY index trend (EMA-based regime classification)
2. Volatility regime (VIX + realized volatility)
3. Market breadth (advances/declines)
4. Relative volume for index futures

Design principles:
- Conservative: Only adds filters, never loosens rules
- Configurable: All thresholds adjustable
- Robust: Graceful fallback when data unavailable
- Non-breaking: Works alongside existing strategies
"""

from __future__ import annotations

import logging
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


@dataclass
class IndexTrendState:
    """Index trend state based on EMA analysis."""
    symbol: str = ""
    ema_fast: float = 0.0  # Fast EMA value
    ema_slow: float = 0.0  # Slow EMA value
    regime: str = "UNKNOWN"  # BULL / BEAR / RANGE_UP / RANGE_DOWN / UNKNOWN
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "symbol": self.symbol,
            "ema_fast": self.ema_fast,
            "ema_slow": self.ema_slow,
            "regime": self.regime,
        }


@dataclass
class VolatilityState:
    """Volatility regime state."""
    vix_spot: float = 0.0  # India VIX spot value
    realized_vol_20d: float = 0.0  # 20-day realized volatility
    regime: str = "UNKNOWN"  # CALM / NORMAL / HIGH / PANIC / UNKNOWN
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "vix_spot": self.vix_spot,
            "realized_vol_20d": self.realized_vol_20d,
            "regime": self.regime,
        }


@dataclass
class BreadthState:
    """Market breadth state."""
    advances: int = 0
    declines: int = 0
    unchanged: int = 0
    
    @property
    def adv_decl_ratio(self) -> float:
        """Advance/decline ratio. Returns 1.0 if no declines."""
        if self.declines == 0:
            return 1.0 if self.advances == 0 else 999.0
        return self.advances / self.declines
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "advances": self.advances,
            "declines": self.declines,
            "unchanged": self.unchanged,
            "adv_decl_ratio": self.adv_decl_ratio,
        }


@dataclass
class MarketContextSnapshot:
    """
    Comprehensive market context snapshot.
    
    Aggregates index trends, volatility, breadth, and relative volume.
    """
    as_of: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    
    # Index trend states (keyed by symbol like "NIFTY", "BANKNIFTY")
    index_trend: Dict[str, IndexTrendState] = field(default_factory=dict)
    
    # Volatility state
    volatility: VolatilityState = field(default_factory=VolatilityState)
    
    # Breadth state
    breadth: BreadthState = field(default_factory=BreadthState)
    
    # Relative volume index (keyed by symbol)
    rvol_index: Dict[str, float] = field(default_factory=dict)
    
    # Session phase
    session_phase: str = "UNKNOWN"  # PRE_OPEN / OPEN / CLOSE / CLOSED
    
    # Metadata
    valid: bool = True  # False if context could not be computed
    errors: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "as_of": self.as_of.isoformat(),
            "index_trend": {k: v.to_dict() for k, v in self.index_trend.items()},
            "volatility": self.volatility.to_dict(),
            "breadth": self.breadth.to_dict(),
            "rvol_index": self.rvol_index,
            "session_phase": self.session_phase,
            "valid": self.valid,
            "errors": self.errors,
        }


class MarketContext:
    """
    MarketContext tracks broad market conditions.
    
    Provides market-wide metrics to inform strategy gating decisions.
    Designed to be conservative - only blocks trades, never loosens rules.
    """
    
    def __init__(
        self,
        kite: Optional[Any] = None,
        config: Optional[Dict[str, Any]] = None,
        logger_instance: Optional[logging.Logger] = None,
    ):
        """
        Initialize MarketContext.
        
        Args:
            kite: KiteConnect client for fetching market data
            config: Configuration dict with thresholds and settings
            logger_instance: Optional logger instance
        """
        self.kite = kite
        self.config = config or {}
        self.logger = logger_instance or logger
        
        # Current snapshot
        self._snapshot: Optional[MarketContextSnapshot] = None
        
        # Configuration with defaults
        self.index_symbols = self.config.get("index_symbols", ["NIFTY", "BANKNIFTY"])
        self.ema_fast_period = self.config.get("ema_fast_period", 20)
        self.ema_slow_period = self.config.get("ema_slow_period", 50)
        self.realized_vol_period = self.config.get("realized_vol_period", 20)
        
        # Volatility thresholds
        self.vix_calm_threshold = self.config.get("vix_calm_threshold", 12.0)
        self.vix_normal_threshold = self.config.get("vix_normal_threshold", 18.0)
        self.vix_high_threshold = self.config.get("vix_high_threshold", 25.0)
        self.vix_panic_threshold = self.config.get("vix_panic_threshold", 35.0)
        
        self.realized_vol_calm_threshold = self.config.get("realized_vol_calm_threshold", 0.10)
        self.realized_vol_normal_threshold = self.config.get("realized_vol_normal_threshold", 0.15)
        self.realized_vol_high_threshold = self.config.get("realized_vol_high_threshold", 0.25)
        self.realized_vol_panic_threshold = self.config.get("realized_vol_panic_threshold", 0.40)
        
        # Equity universe for breadth
        self.equity_universe = self.config.get("equity_universe", [])
        
        # Cache for bar data
        self._bar_cache: Dict[str, List[Dict[str, float]]] = {}
        
        self.logger.info(
            "MarketContext initialized: indices=%s, ema_fast=%d, ema_slow=%d",
            self.index_symbols,
            self.ema_fast_period,
            self.ema_slow_period,
        )
    
    @property
    def snapshot(self) -> Optional[MarketContextSnapshot]:
        """Get the latest market context snapshot."""
        return self._snapshot
    
    def refresh(self, now: Optional[datetime] = None) -> MarketContextSnapshot:
        """
        Refresh market context by computing all metrics.
        
        Args:
            now: Optional timestamp to use (defaults to current time)
        
        Returns:
            Updated MarketContextSnapshot
        """
        now = now or datetime.now(timezone.utc)
        
        # Create new snapshot
        snapshot = MarketContextSnapshot(as_of=now)
        errors = []
        
        try:
            # 1. Compute session phase
            snapshot.session_phase = self._compute_session_phase(now)
            
            # 2. Compute index trends
            for symbol in self.index_symbols:
                try:
                    trend_state = self._compute_index_trend(symbol)
                    snapshot.index_trend[symbol] = trend_state
                except Exception as exc:
                    self.logger.warning("Failed to compute trend for %s: %s", symbol, exc)
                    errors.append(f"index_trend_{symbol}: {exc}")
                    snapshot.index_trend[symbol] = IndexTrendState(symbol=symbol, regime="UNKNOWN")
            
            # 3. Compute volatility state
            try:
                snapshot.volatility = self._compute_volatility_state()
            except Exception as exc:
                self.logger.warning("Failed to compute volatility: %s", exc)
                errors.append(f"volatility: {exc}")
                snapshot.volatility = VolatilityState(regime="UNKNOWN")
            
            # 4. Compute breadth
            try:
                snapshot.breadth = self._compute_breadth()
            except Exception as exc:
                self.logger.warning("Failed to compute breadth: %s", exc)
                errors.append(f"breadth: {exc}")
                snapshot.breadth = BreadthState()
            
            # 5. Compute relative volume for indices
            for symbol in self.index_symbols:
                try:
                    rvol = self._compute_relative_volume(symbol)
                    snapshot.rvol_index[symbol] = rvol
                except Exception as exc:
                    self.logger.debug("Failed to compute rvol for %s: %s", symbol, exc)
                    snapshot.rvol_index[symbol] = 1.0  # Neutral default
            
        except Exception as exc:
            self.logger.error("Failed to refresh market context: %s", exc, exc_info=True)
            errors.append(f"refresh_error: {exc}")
        
        snapshot.errors = errors
        snapshot.valid = len(errors) == 0
        
        # Store snapshot
        self._snapshot = snapshot
        
        # Log single-line summary
        self._log_snapshot_summary(snapshot)
        
        return snapshot
    
    def _compute_session_phase(self, now: datetime) -> str:
        """
        Determine market session phase based on IST time.
        
        Returns:
            "PRE_OPEN", "OPEN", "CLOSE", or "CLOSED"
        """
        # Convert to IST (UTC+5:30)
        ist_offset_minutes = 330  # 5 hours 30 minutes
        ist_time = now.timestamp() + (ist_offset_minutes * 60)
        ist_dt = datetime.fromtimestamp(ist_time, tz=timezone.utc)
        
        hour = ist_dt.hour
        minute = ist_dt.minute
        
        # Market timings (IST):
        # Pre-open: 9:00 - 9:15
        # Open: 9:15 - 15:30
        # Close: after 15:30
        
        if hour < 9:
            return "CLOSED"
        elif hour == 9 and minute < 15:
            return "PRE_OPEN"
        elif hour < 15 or (hour == 15 and minute < 30):
            return "OPEN"
        else:
            return "CLOSED"
    
    def _compute_index_trend(self, symbol: str) -> IndexTrendState:
        """
        Compute index trend state using EMA crossover.
        
        Returns:
            IndexTrendState with regime classification
        """
        # Fetch recent bars for the index
        bars = self._fetch_bars(symbol, period="5minute", count=100)
        
        if not bars or len(bars) < max(self.ema_fast_period, self.ema_slow_period):
            return IndexTrendState(symbol=symbol, regime="UNKNOWN")
        
        # Extract close prices
        closes = [bar.get("close", 0.0) for bar in bars]
        
        # Compute EMAs
        from core.indicators import ema
        
        try:
            ema_fast = ema(closes, self.ema_fast_period)
            ema_slow = ema(closes, self.ema_slow_period)
        except Exception as exc:
            self.logger.debug("Failed to compute EMAs for %s: %s", symbol, exc)
            return IndexTrendState(symbol=symbol, regime="UNKNOWN")
        
        # Classify regime
        regime = self._classify_trend_regime(ema_fast, ema_slow, closes[-1])
        
        return IndexTrendState(
            symbol=symbol,
            ema_fast=ema_fast,
            ema_slow=ema_slow,
            regime=regime,
        )
    
    def _classify_trend_regime(self, ema_fast: float, ema_slow: float, current_price: float) -> str:
        """
        Classify trend regime based on EMA positions.
        
        Returns:
            "BULL", "BEAR", "RANGE_UP", "RANGE_DOWN", or "UNKNOWN"
        """
        if ema_fast <= 0 or ema_slow <= 0:
            return "UNKNOWN"
        
        # Calculate separation as percentage
        separation = abs(ema_fast - ema_slow) / ema_slow
        
        # Strong trend threshold
        strong_threshold = 0.005  # 0.5% separation
        
        if ema_fast > ema_slow:
            # Fast above slow - bullish
            if separation > strong_threshold:
                return "BULL"
            else:
                return "RANGE_UP"
        else:
            # Fast below slow - bearish
            if separation > strong_threshold:
                return "BEAR"
            else:
                return "RANGE_DOWN"
    
    def _compute_volatility_state(self) -> VolatilityState:
        """
        Compute volatility regime using VIX and realized volatility.
        
        Returns:
            VolatilityState with regime classification
        """
        # Try to fetch VIX
        vix_spot = self._fetch_vix()
        
        # Compute realized volatility for NIFTY
        realized_vol = self._compute_realized_volatility("NIFTY")
        
        # Classify regime based on both VIX and realized vol
        regime = self._classify_volatility_regime(vix_spot, realized_vol)
        
        return VolatilityState(
            vix_spot=vix_spot,
            realized_vol_20d=realized_vol,
            regime=regime,
        )
    
    def _classify_volatility_regime(self, vix_spot: float, realized_vol: float) -> str:
        """
        Classify volatility regime.
        
        Uses VIX as primary indicator, realized vol as secondary.
        
        Returns:
            "CALM", "NORMAL", "HIGH", "PANIC", or "UNKNOWN"
        """
        # If VIX is available, use it
        if vix_spot > 0:
            if vix_spot < self.vix_calm_threshold:
                return "CALM"
            elif vix_spot < self.vix_normal_threshold:
                return "NORMAL"
            elif vix_spot < self.vix_high_threshold:
                return "HIGH"
            elif vix_spot < self.vix_panic_threshold:
                return "HIGH"
            else:
                return "PANIC"
        
        # Fallback to realized volatility
        if realized_vol > 0:
            if realized_vol < self.realized_vol_calm_threshold:
                return "CALM"
            elif realized_vol < self.realized_vol_normal_threshold:
                return "NORMAL"
            elif realized_vol < self.realized_vol_high_threshold:
                return "HIGH"
            elif realized_vol < self.realized_vol_panic_threshold:
                return "HIGH"
            else:
                return "PANIC"
        
        return "UNKNOWN"
    
    def _compute_breadth(self) -> BreadthState:
        """
        Compute market breadth from equity universe.
        
        Returns:
            BreadthState with advances, declines, unchanged counts
        """
        if not self.equity_universe:
            return BreadthState()
        
        advances = 0
        declines = 0
        unchanged = 0
        
        for symbol in self.equity_universe:
            try:
                # Get latest 2 candles to compute change
                bars = self._fetch_bars(symbol, period="5minute", count=2)
                if len(bars) < 2:
                    continue
                
                prev_close = bars[-2].get("close", 0.0)
                curr_close = bars[-1].get("close", 0.0)
                
                if prev_close <= 0 or curr_close <= 0:
                    continue
                
                change_pct = ((curr_close - prev_close) / prev_close) * 100
                
                if change_pct > 0.1:
                    advances += 1
                elif change_pct < -0.1:
                    declines += 1
                else:
                    unchanged += 1
                    
            except Exception as exc:
                self.logger.debug("Failed to compute breadth for %s: %s", symbol, exc)
                continue
        
        return BreadthState(
            advances=advances,
            declines=declines,
            unchanged=unchanged,
        )
    
    def _compute_relative_volume(self, symbol: str) -> float:
        """
        Compute relative volume for a symbol.
        
        RVOL = current_volume / average_volume(last N periods)
        
        Returns:
            Relative volume ratio (1.0 = average)
        """
        bars = self._fetch_bars(symbol, period="5minute", count=self.realized_vol_period + 1)
        
        if not bars or len(bars) < 2:
            return 1.0
        
        current_volume = bars[-1].get("volume", 0.0)
        if current_volume <= 0:
            return 1.0
        
        # Average volume over previous periods
        volumes = [bar.get("volume", 0.0) for bar in bars[:-1]]
        avg_volume = sum(volumes) / len(volumes) if volumes else 1.0
        
        if avg_volume <= 0:
            return 1.0
        
        return current_volume / avg_volume
    
    def _fetch_bars(self, symbol: str, period: str = "5minute", count: int = 100) -> List[Dict[str, float]]:
        """
        Fetch historical bars for a symbol.
        
        Uses cache to avoid excessive API calls.
        
        Args:
            symbol: Trading symbol
            period: Bar period (e.g., "5minute", "day")
            count: Number of bars to fetch
        
        Returns:
            List of OHLCV bar dicts
        """
        # Check cache
        cache_key = f"{symbol}_{period}_{count}"
        if cache_key in self._bar_cache:
            # TODO: Add cache expiry check
            return self._bar_cache[cache_key]
        
        # Fetch from Kite if available
        if not self.kite:
            return []
        
        try:
            # Use existing bar loader utilities if available
            from core.history_loader import load_intraday_bars
            
            # Calculate date range (fetch last few days to get enough bars)
            from datetime import timedelta
            to_date = datetime.now()
            from_date = to_date - timedelta(days=5)
            
            bars = load_intraday_bars(
                self.kite,
                symbol,
                from_date,
                to_date,
                interval=period,
            )
            
            # Cache the result
            self._bar_cache[cache_key] = bars[-count:] if bars else []
            
            return self._bar_cache[cache_key]
            
        except Exception as exc:
            self.logger.debug("Failed to fetch bars for %s: %s", symbol, exc)
            return []
    
    def _fetch_vix(self) -> float:
        """
        Fetch India VIX spot value.
        
        Returns:
            VIX value or 0.0 if unavailable
        """
        if not self.kite:
            return 0.0
        
        try:
            # Try to fetch VIX quote
            quotes = self.kite.quote(["NSE:INDIA VIX"])
            if quotes and "NSE:INDIA VIX" in quotes:
                return float(quotes["NSE:INDIA VIX"].get("last_price", 0.0))
        except Exception as exc:
            self.logger.debug("Failed to fetch VIX: %s", exc)
        
        try:
            # Try alternate symbol
            quotes = self.kite.quote(["NSE:INDIAVIX"])
            if quotes and "NSE:INDIAVIX" in quotes:
                return float(quotes["NSE:INDIAVIX"].get("last_price", 0.0))
        except Exception as exc:
            self.logger.debug("Failed to fetch VIX (alternate): %s", exc)
        
        return 0.0
    
    def _compute_realized_volatility(self, symbol: str) -> float:
        """
        Compute realized volatility (stddev of returns).
        
        Args:
            symbol: Trading symbol
        
        Returns:
            Annualized realized volatility or 0.0 if unavailable
        """
        bars = self._fetch_bars(symbol, period="day", count=self.realized_vol_period + 1)
        
        if not bars or len(bars) < self.realized_vol_period:
            return 0.0
        
        # Compute log returns
        import math
        
        returns = []
        for i in range(1, len(bars)):
            prev_close = bars[i - 1].get("close", 0.0)
            curr_close = bars[i].get("close", 0.0)
            
            if prev_close > 0 and curr_close > 0:
                log_return = math.log(curr_close / prev_close)
                returns.append(log_return)
        
        if not returns:
            return 0.0
        
        # Compute standard deviation
        mean_return = sum(returns) / len(returns)
        variance = sum((r - mean_return) ** 2 for r in returns) / len(returns)
        daily_vol = math.sqrt(variance)
        
        # Annualize (assuming 252 trading days)
        annualized_vol = daily_vol * math.sqrt(252)
        
        return annualized_vol
    
    def _log_snapshot_summary(self, snapshot: MarketContextSnapshot) -> None:
        """Log a compact single-line summary of the snapshot."""
        # Build index trends summary
        index_trends = ", ".join(
            f"{sym}={state.regime}" for sym, state in snapshot.index_trend.items()
        )
        
        # Build rvol summary
        rvol_summary = ", ".join(
            f"{sym}={val:.2f}" for sym, val in snapshot.rvol_index.items()
        )
        
        self.logger.info(
            "MarketContext: phase=%s | trends=[%s] | vol=%s(vix=%.1f,rvol=%.2f) | breadth=%d/%d(%.2f) | rvol=[%s] | valid=%s",
            snapshot.session_phase,
            index_trends,
            snapshot.volatility.regime,
            snapshot.volatility.vix_spot,
            snapshot.volatility.realized_vol_20d,
            snapshot.breadth.advances,
            snapshot.breadth.declines,
            snapshot.breadth.adv_decl_ratio,
            rvol_summary,
            snapshot.valid,
        )


@dataclass
class MarketContextConfig:
    """Configuration for MarketContext computation."""
    enabled: bool = False
    
    # VIX configuration
    vix_enabled: bool = True
    vix_symbol: str = "INDIA VIX"
    vix_low_threshold: float = 12.0
    vix_normal_threshold: float = 18.0
    vix_high_threshold: float = 25.0
    vix_panic_threshold: float = 35.0
    
    # Breadth configuration
    breadth_enabled: bool = True
    breadth_universe: str = "NIFTY50"  # Which universe to compute breadth for
    breadth_ema_periods: List[int] = field(default_factory=lambda: [20, 50])
    
    # Relative volume configuration
    rvol_enabled: bool = True
    rvol_lookback_periods: int = 20  # Average volume over N periods
    rvol_min_threshold: float = 0.7  # Minimum RVOL for entries
    
    # Filter configuration
    block_shorts_on_panic: bool = True
    require_stronger_edge_on_weak_breadth: bool = True
    skip_low_rvol: bool = True
    
    @classmethod
    def from_dict(cls, cfg: Optional[Dict[str, Any]]) -> "MarketContextConfig":
        """Create config from dictionary."""
        if not cfg:
            return cls()
        
        # Extract nested configs
        vix_cfg = cfg.get("vix", {})
        breadth_cfg = cfg.get("breadth", {})
        rvol_cfg = cfg.get("relative_volume", {})
        filters_cfg = cfg.get("filters", {})
        
        return cls(
            enabled=cfg.get("enabled", False),
            # VIX
            vix_enabled=vix_cfg.get("enabled", True),
            vix_symbol=vix_cfg.get("symbol", "INDIA VIX"),
            vix_low_threshold=float(vix_cfg.get("low_threshold", 12.0)),
            vix_normal_threshold=float(vix_cfg.get("normal_threshold", 18.0)),
            vix_high_threshold=float(vix_cfg.get("high_threshold", 25.0)),
            vix_panic_threshold=float(vix_cfg.get("panic_threshold", 35.0)),
            # Breadth
            breadth_enabled=breadth_cfg.get("enabled", True),
            breadth_universe=breadth_cfg.get("universe", "NIFTY50"),
            breadth_ema_periods=breadth_cfg.get("ema_periods", [20, 50]),
            # RVOL
            rvol_enabled=rvol_cfg.get("enabled", True),
            rvol_lookback_periods=int(rvol_cfg.get("lookback_periods", 20)),
            rvol_min_threshold=float(rvol_cfg.get("min_rvol", 0.7)),
            # Filters
            block_shorts_on_panic=filters_cfg.get("block_shorts_on_panic", True),
            require_stronger_edge_on_weak_breadth=filters_cfg.get("require_stronger_edge_on_weak_breadth", True),
            skip_low_rvol=filters_cfg.get("skip_low_rvol", True),
        )


class MarketContextBuilder:
    """
    Builder for MarketContext.
    
    Computes market-wide metrics from various data sources.
    """
    
    def __init__(
        self,
        config: MarketContextConfig,
        kite_client: Optional[Any] = None,
        market_data_engine: Optional[Any] = None,
        logger_instance: Optional[logging.Logger] = None,
    ):
        """
        Initialize MarketContextBuilder.
        
        Args:
            config: MarketContextConfig instance
            kite_client: Optional KiteConnect client for VIX data
            market_data_engine: Optional MarketDataEngine for price/volume data
            logger_instance: Optional logger instance
        """
        self.config = config
        self.kite = kite_client
        self.mde = market_data_engine
        self.logger = logger_instance or logger
        
        # Cache for performance
        self._vix_cache: Optional[float] = None
        self._vix_cache_time: Optional[datetime] = None
        self._vix_cache_ttl_seconds = 60  # Cache VIX for 60 seconds
        
        self.logger.info(
            "MarketContextBuilder initialized: enabled=%s, vix=%s, breadth=%s, rvol=%s",
            self.config.enabled,
            self.config.vix_enabled,
            self.config.breadth_enabled,
            self.config.rvol_enabled,
        )
    
    def build(self, symbols: Optional[List[str]] = None) -> MarketContext:
        """
        Build MarketContext snapshot.
        
        Args:
            symbols: Optional list of symbols for RVOL computation
        
        Returns:
            MarketContext with current market metrics
        """
        if not self.config.enabled:
            # Return minimal context when disabled
            return MarketContext(
                valid=False,
                errors=["market_context_disabled"],
            )
        
        context = MarketContext()
        errors = []
        
        # 1. Compute VIX regime
        if self.config.vix_enabled:
            try:
                vix_value, vix_regime = self._compute_vix_regime()
                context.vix_value = vix_value
                context.vix_regime = vix_regime
            except Exception as exc:
                self.logger.warning("Failed to compute VIX regime: %s", exc)
                errors.append(f"vix_error: {exc}")
                context.vix_regime = "unknown"
        
        # 2. Compute market breadth
        if self.config.breadth_enabled:
            try:
                breadth = self._compute_breadth()
                context.advances = breadth["advances"]
                context.declines = breadth["declines"]
                context.unchanged = breadth["unchanged"]
                context.pct_above_20ema = breadth.get("pct_above_20ema", 0.0)
                context.pct_above_50ema = breadth.get("pct_above_50ema", 0.0)
            except Exception as exc:
                self.logger.warning("Failed to compute breadth: %s", exc)
                errors.append(f"breadth_error: {exc}")
        
        # 3. Compute relative volume
        if self.config.rvol_enabled and symbols:
            try:
                rvol_map = self._compute_relative_volume(symbols)
                context.symbol_rvol = rvol_map
            except Exception as exc:
                self.logger.warning("Failed to compute relative volume: %s", exc)
                errors.append(f"rvol_error: {exc}")
        
        context.timestamp = datetime.now(timezone.utc)
        context.errors = errors
        context.valid = len(errors) == 0
        
        if not context.valid:
            self.logger.debug("MarketContext built with errors: %s", errors)
        
        return context
    
    def _compute_vix_regime(self) -> tuple[float, str]:
        """
        Compute India VIX regime.
        
        Returns:
            (vix_value, regime) where regime is "low", "normal", "high", "panic", or "unknown"
        """
        # Check cache first
        now = datetime.now(timezone.utc)
        if self._vix_cache is not None and self._vix_cache_time:
            age = (now - self._vix_cache_time).total_seconds()
            if age < self._vix_cache_ttl_seconds:
                return self._vix_cache, self._classify_vix_regime(self._vix_cache)
        
        # Try to fetch VIX from Kite
        vix_value = self._fetch_india_vix()
        
        if vix_value is None:
            # Fallback: Try to get from market data engine
            if self.mde:
                try:
                    # Try common VIX symbol variations
                    for symbol in ["INDIA VIX", "INDIAVIX", "NSE:INDIA VIX"]:
                        try:
                            quote = self.mde.get_quote(symbol)
                            if quote and "last_price" in quote:
                                vix_value = float(quote["last_price"])
                                break
                        except Exception:
                            continue
                except Exception as exc:
                    self.logger.debug("Could not get VIX from MDE: %s", exc)
        
        if vix_value is None:
            # Final fallback: Use neutral default
            self.logger.warning("Could not fetch India VIX, using neutral regime")
            return 0.0, "unknown"
        
        # Cache the value
        self._vix_cache = vix_value
        self._vix_cache_time = now
        
        regime = self._classify_vix_regime(vix_value)
        return vix_value, regime
    
    def _fetch_india_vix(self) -> Optional[float]:
        """
        Fetch India VIX value from Kite API.
        
        Returns:
            VIX value or None if unavailable
        """
        if not self.kite:
            return None
        
        try:
            # India VIX instrument token (NSE)
            # Note: This may need to be looked up via instruments API
            # For now, try common approaches
            
            # Method 1: Try quote API
            try:
                quotes = self.kite.quote(["NSE:INDIA VIX"])
                if quotes and "NSE:INDIA VIX" in quotes:
                    return float(quotes["NSE:INDIA VIX"]["last_price"])
            except Exception as exc:
                self.logger.debug("VIX quote method 1 failed: %s", exc)
            
            # Method 2: Try alternate symbol
            try:
                quotes = self.kite.quote(["NSE:INDIAVIX"])
                if quotes and "NSE:INDIAVIX" in quotes:
                    return float(quotes["NSE:INDIAVIX"]["last_price"])
            except Exception as exc:
                self.logger.debug("VIX quote method 2 failed: %s", exc)
            
            return None
            
        except Exception as exc:
            self.logger.debug("Failed to fetch India VIX: %s", exc)
            return None
    
    def _classify_vix_regime(self, vix_value: float) -> str:
        """
        Classify VIX regime based on thresholds.
        
        Args:
            vix_value: Current VIX value
        
        Returns:
            Regime classification
        """
        if vix_value <= 0:
            return "unknown"
        elif vix_value < self.config.vix_low_threshold:
            return "low"
        elif vix_value < self.config.vix_normal_threshold:
            return "normal"
        elif vix_value < self.config.vix_high_threshold:
            return "high"
        elif vix_value < self.config.vix_panic_threshold:
            return "very_high"
        else:
            return "panic"
    
    def _compute_breadth(self) -> Dict[str, Any]:
        """
        Compute market breadth metrics.
        
        Returns:
            Dict with advances, declines, unchanged, pct_above_20ema, pct_above_50ema
        """
        if not self.mde:
            # No data source, return zeros
            return {
                "advances": 0,
                "declines": 0,
                "unchanged": 0,
                "pct_above_20ema": 0.0,
                "pct_above_50ema": 0.0,
            }
        
        # Get universe symbols based on config
        universe_symbols = self._get_breadth_universe()
        
        if not universe_symbols:
            self.logger.warning("No symbols in breadth universe: %s", self.config.breadth_universe)
            return {
                "advances": 0,
                "declines": 0,
                "unchanged": 0,
                "pct_above_20ema": 0.0,
                "pct_above_50ema": 0.0,
            }
        
        advances = 0
        declines = 0
        unchanged = 0
        above_20ema = 0
        above_50ema = 0
        valid_count = 0
        
        for symbol in universe_symbols:
            try:
                # Get latest candle and indicators
                candle = self.mde.get_latest_candle(symbol, "5m")
                if not candle:
                    continue
                
                close = candle.get("close", 0.0)
                open_price = candle.get("open", 0.0)
                
                if close <= 0 or open_price <= 0:
                    continue
                
                valid_count += 1
                
                # Advance/Decline logic
                if close > open_price * 1.001:  # Up > 0.1%
                    advances += 1
                elif close < open_price * 0.999:  # Down > 0.1%
                    declines += 1
                else:
                    unchanged += 1
                
                # Check EMAs
                # Get window for EMA computation
                window = self.mde.get_window(symbol, "5m", 60)
                if window and len(window) >= 50:
                    closes = [c["close"] for c in window]
                    
                    # Compute EMAs
                    from core.indicators import ema
                    
                    try:
                        ema20 = ema(closes, 20)
                        if close > ema20:
                            above_20ema += 1
                    except Exception:
                        pass
                    
                    try:
                        ema50 = ema(closes, 50)
                        if close > ema50:
                            above_50ema += 1
                    except Exception:
                        pass
                
            except Exception as exc:
                self.logger.debug("Error processing symbol %s for breadth: %s", symbol, exc)
                continue
        
        # Compute percentages
        if valid_count > 0:
            pct_20 = (above_20ema / valid_count) * 100.0
            pct_50 = (above_50ema / valid_count) * 100.0
        else:
            pct_20 = 0.0
            pct_50 = 0.0
        
        return {
            "advances": advances,
            "declines": declines,
            "unchanged": unchanged,
            "pct_above_20ema": pct_20,
            "pct_above_50ema": pct_50,
        }
    
    def _get_breadth_universe(self) -> List[str]:
        """
        Get list of symbols for breadth computation.
        
        Returns:
            List of symbol strings
        """
        # This would ideally load from a universe config or file
        # For now, return a placeholder list
        
        if self.config.breadth_universe == "NIFTY50":
            # Placeholder: In production, load from config/universe_nifty50.csv
            # or fetch from Kite API indices
            return [
                "RELIANCE", "TCS", "HDFCBANK", "INFY", "ICICIBANK",
                "HINDUNILVR", "ITC", "SBIN", "BHARTIARTL", "KOTAKBANK",
                # ... would include all 50 symbols
            ]
        elif self.config.breadth_universe == "NIFTY100":
            # Placeholder
            return []
        else:
            # Try to get from MDE if available
            if self.mde and hasattr(self.mde, "get_universe"):
                try:
                    return self.mde.get_universe()
                except Exception:
                    pass
            return []
    
    def _compute_relative_volume(self, symbols: List[str]) -> Dict[str, float]:
        """
        Compute relative volume for each symbol.
        
        Relative volume = current_volume / avg_volume(N periods)
        
        Args:
            symbols: List of symbols to compute RVOL for
        
        Returns:
            Dict mapping symbol -> RVOL
        """
        if not self.mde:
            return {}
        
        rvol_map = {}
        
        for symbol in symbols:
            try:
                # Get window of candles
                window = self.mde.get_window(symbol, "5m", self.config.rvol_lookback_periods + 1)
                
                if not window or len(window) < 2:
                    continue
                
                # Current volume
                current_volume = window[-1].get("volume", 0.0)
                
                if current_volume <= 0:
                    continue
                
                # Average volume over lookback period (excluding current)
                volumes = [c.get("volume", 0.0) for c in window[:-1]]
                avg_volume = sum(volumes) / len(volumes) if volumes else 1.0
                
                if avg_volume <= 0:
                    avg_volume = 1.0
                
                rvol = current_volume / avg_volume
                rvol_map[symbol] = rvol
                
            except Exception as exc:
                self.logger.debug("Error computing RVOL for %s: %s", symbol, exc)
                continue
        
        return rvol_map
    
    def should_allow_entry(
        self,
        context: MarketContext,
        symbol: str,
        signal: str,
        confidence: float,
    ) -> tuple[bool, str]:
        """
        Check if entry should be allowed based on market context.
        
        Args:
            context: Current MarketContext
            symbol: Trading symbol
            signal: "BUY" or "SELL"
            confidence: Signal confidence (0-1)
        
        Returns:
            (allowed, reason) tuple
        """
        if not self.config.enabled:
            return True, "context_disabled"
        
        # VIX filter: Block shorts on panic
        if self.config.block_shorts_on_panic:
            if signal in ["SELL", "SHORT"] and context.vix_regime in ["panic", "very_high"]:
                return False, f"vix_{context.vix_regime}_no_shorts"
        
        # Breadth filter: Require stronger edge when breadth is weak
        if self.config.require_stronger_edge_on_weak_breadth:
            if signal in ["BUY", "LONG"] and context.pct_above_20ema < 30.0:
                # Market breadth is weak (< 30% above 20 EMA)
                # Require higher confidence
                if confidence < 0.7:
                    return False, "weak_breadth_low_confidence"
        
        # RVOL filter: Skip low relative volume entries
        if self.config.skip_low_rvol:
            rvol = context.symbol_rvol.get(symbol, 1.0)
            if rvol < self.config.rvol_min_threshold:
                return False, f"low_rvol_{rvol:.2f}"
        
        return True, "context_ok"


# Singleton instance for global access
_global_builder: Optional[MarketContextBuilder] = None


def initialize_market_context(
    config: Dict[str, Any],
    kite_client: Optional[Any] = None,
    market_data_engine: Optional[Any] = None,
) -> MarketContextBuilder:
    """
    Initialize global MarketContextBuilder.
    
    Args:
        config: Application config dict
        kite_client: Optional KiteConnect client
        market_data_engine: Optional MarketDataEngine
    
    Returns:
        Initialized MarketContextBuilder
    """
    global _global_builder
    
    mc_config = MarketContextConfig.from_dict(config.get("market_context"))
    _global_builder = MarketContextBuilder(
        config=mc_config,
        kite_client=kite_client,
        market_data_engine=market_data_engine,
    )
    
    return _global_builder


def get_market_context_builder() -> Optional[MarketContextBuilder]:
    """Get the global MarketContextBuilder instance."""
    return _global_builder


def build_market_context(symbols: Optional[List[str]] = None) -> MarketContext:
    """
    Build MarketContext using global builder.
    
    Args:
        symbols: Optional list of symbols for RVOL
    
    Returns:
        MarketContext snapshot
    """
    if _global_builder is None:
        # Return minimal context if not initialized
        return MarketContext(
            valid=False,
            errors=["market_context_not_initialized"],
        )
    
    return _global_builder.build(symbols)
